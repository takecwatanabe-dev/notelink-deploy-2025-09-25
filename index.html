<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>NOTE LINK — v0.8.0-compat-02d-fix1</title>
<style>
  :root{
    --bg:#0f1115; --pane:#171a21; --ink:#111; --fg:#e9eef5; --muted:#92a0b3; --accent:#50C878;
    --toolbar-w:72px; --toolbar-collapsed:14px; --bar-h:44px; --shadow:0 6px 24px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif}
  #topbar{
    position:fixed;left:0;top:0;right:0;height:var(--bar-h);display:flex;align-items:center;
    gap:8px;background:var(--pane);border-bottom:1px solid #222;z-index:1000;padding:0 8px
  }
  #topbar .title{font-weight:700;letter-spacing:.3px}
  #topbar .version{font-size:12px;color:var(--muted);margin-left:6px}
  #topbar .spacer{flex:1}
  #topbar button{
    height:30px;min-width:32px;border:1px solid #2a2f3a;border-radius:10px;background:#1a1f29;color:var(--fg);
    cursor:pointer;padding:0 10px
  }
  #stage{
    position:absolute;left:0;top:var(--bar-h);right:0;bottom:0;display:flex
  }
  #sidebar{
    width:var(--toolbar-w);background:var(--pane);border-right:1px solid #222;box-shadow:var(--shadow);
    display:flex;flex-direction:column;gap:8px;padding:10px;z-index:900;transition:transform .18s ease;
  }
  #sidebar.collapsed{transform:translateX(calc(-1*var(--toolbar-w) + var(--toolbar-collapsed)))}
  #sidebar .toggle{
    position:absolute;right:-14px;top:10px;width:28px;height:28px;border-radius:14px;border:1px solid #2a2f3a;background:#1a1f29;
    display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:1200
  }
  #sidebar .row{display:flex;gap:6px;flex-wrap:wrap}
  #sidebar button.tool{
    width:48px;height:48px;border-radius:14px;border:1px solid #2a2f3a;background:#141922;color:var(--fg);cursor:pointer
  }
  #sidebar button.tool.active{outline:2px solid var(--accent)}
  #sidebar .section{border-top:1px solid #232733;padding-top:8px;margin-top:4px}
  label{font-size:12px;color:var(--muted)}
  input[type="range"]{width:100%}
  #canvasWrap{position:relative;flex:1;overflow:hidden;background:#0c0e12}
  #canvas{position:absolute;left:0;top:0}
  #debug{
    position:absolute;left:8px;bottom:8px;min-width:260px;max-width:60%;
    background:rgba(0,0,0,.55);border:1px solid #2a2f3a;border-radius:10px;padding:8px;font:12px/1.4 ui-monospace,Menlo,Consolas,monospace
  }
  /* modal */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:1400}
  .dialog{background:#141922;border:1px solid #2a2f3a;border-radius:16px;min-width:320px;max-width:90vw;padding:14px;box-shadow:var(--shadow)}
  .dialog h3{margin:0 0 8px 0}
  .dialog .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
  .pill{border:1px solid #2a2f3a;border-radius:999px;padding:6px 10px;background:#1a1f29;color:var(--fg)}
  .kbd{display:inline-flex;align-items:center;justify-content:center;min-width:24px;border:1px solid #2a2f3a;border-bottom:2px solid #2d3340;border-radius:6px;padding:0 6px;height:22px;background:#0f131a;margin:0 2px}
</style>
</head>
<body>
  <div id="topbar" role="toolbar" aria-label="Top bar">
    <button id="toggleSidebarBtn" title="サイドバー開閉">☰</button>
    <div class="title">NOTE LINK</div>
    <div class="version">v0.8.0-compat-02d-fix1</div>
    <div class="spacer"></div>
    <button id="undoBtn" title="元に戻す (Ctrl+Z)">↶</button>
    <button id="redoBtn" title="やり直し (Ctrl+Shift+Z)">↷</button>
  </div>

  <div id="stage">
    <aside id="sidebar" class="">
      <div class="toggle" id="sidebarToggle" title="開閉">◀</div>
      <div class="row" aria-label="tools">
        <button class="tool" data-tool="hand" title="Hand(パン) 🤚">🤚</button>
        <button class="tool" data-tool="pen" title="Pen ✒️">✒️</button>
        <button class="tool" data-tool="marker" title="Marker 🖍️">🖍️</button>
        <button class="tool" data-tool="eraser" title="Eraser 🩹">🩹</button>
      </div>

      <div class="section">
        <label>太さ <span id="widthLabel">(2.0 mm / 5.7 pt)</span></label>
        <input type="range" id="widthRange" min="0.2" max="8" step="0.1" value="2">
      </div>

      <div class="section">
        <label>色</label><br>
        <input type="color" id="colorPick" value="#111111">
      </div>

      <div class="section">
        <label><input type="checkbox" id="palmCheck" checked> パームリジェクション（手のひらを無視）</label>
      </div>

      <div class="section">
        <button id="textBtn" class="pill">⌨️ テキスト</button>
        <button id="gearBtn" class="pill">⚙️ 設定</button>
      </div>
    </aside>

    <div id="canvasWrap">
      <canvas id="canvas"></canvas>
      <div id="debug" hidden></div>
    </div>
  </div>

  <!-- Text dialog -->
  <div id="textModal" class="modal" hidden>
    <div class="dialog">
      <h3>テキストを追加</h3>
      <div style="display:flex;flex-direction:column;gap:8px;">
        <input id="textInput" class="pill" placeholder="ここに文字を入力">
        <div style="display:flex;gap:8px;align-items:center;">
          <label>サイズ(pt)</label>
          <input id="textSize" type="number" class="pill" value="18" min="8" max="72" step="1" style="width:90px">
          <label>色</label><input id="textColor" type="color" value="#ffffff">
        </div>
        <div><span class="kbd">Esc</span> で閉じる／キャンバス上クリックで配置</div>
      </div>
      <div class="actions">
        <button id="textCancel" class="pill">閉じる</button>
        <button id="textOk" class="pill">配置モード</button>
      </div>
    </div>
  </div>

  <!-- Settings -->
  <div id="gearModal" class="modal" hidden>
    <div class="dialog">
      <h3>設定</h3>
      <label><input type="checkbox" id="debugCheck"> デバッグ情報を表示（?debug=1 でも可）</label>
      <div class="actions">
        <button id="gearClose" class="pill">閉じる</button>
      </div>
    </div>
  </div>

<script>
(()=>{
  const $ = (q,root=document)=>root.querySelector(q);
  const $$ = (q,root=document)=>Array.from(root.querySelectorAll(q));
  const qs = new URLSearchParams(location.search);
  const DEBUG_URL = qs.get('debug') === '1';

  // --- Canvas state (ワールド座標で保持し、拡大縮小しても再描画で消えない) ---
  const canvas = $('#canvas');
  const wrap = $('#canvasWrap');
  const ctx = canvas.getContext('2d');

  const state = {
    tool:'pen', color:'#111111', widthMM:2.0,
    scale:1, tx:0, ty:0,   // ビューポート変換
    drawing:false, currentStroke:null, pointerId:null,
    strokes:[], redoStack:[],  // Undo/Redo
    placingText:null
  };

  const support = {
    dpi:96, // CSS px/inch 相当
    get mm2px(){ return this.dpi/25.4; },
    worldFromClient(x,y){
      const rect = canvas.getBoundingClientRect();
      const cx = (x - rect.left);
      const cy = (y - rect.top);
      return { x:(cx - state.tx)/state.scale, y:(cy - state.ty)/state.scale };
    }
  };

  // --- Resize & DPR ---
  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = wrap.clientWidth, h = wrap.clientHeight;
    canvas.style.width = w+'px'; canvas.style.height = h+'px';
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    render(); // 再描画
  }
  window.addEventListener('resize', fitCanvas, {passive:true});
  fitCanvas();

  // --- UI wiring ---
  const tools = $$('#sidebar .tool');
  function setTool(t){
    state.tool = t;
    tools.forEach(b=>b.classList.toggle('active', b.dataset.tool===t));
  }
  tools.forEach(b=>b.addEventListener('click', ()=>setTool(b.dataset.tool)));
  setTool('pen');

  const widthRange = $('#widthRange'); const widthLabel = $('#widthLabel');
  function updateWidthLabel(){
    const mm = parseFloat(widthRange.value);
    const pt = mm * 2.83465; // 1pt = 1/72in
    widthLabel.textContent = `(${mm.toFixed(1)} mm / ${pt.toFixed(1)} pt)`;
    state.widthMM = mm;
  }
  widthRange.addEventListener('input', updateWidthLabel); updateWidthLabel();

  const colorPick = $('#colorPick');
  colorPick.addEventListener('input', ()=> state.color = colorPick.value);

  const palmCheck = $('#palmCheck');

  // Sidebar toggle（クリック取りこぼし対策：高z-index, pointer-events明示）
  const sidebar = $('#sidebar');
  const sidebarToggle = $('#sidebarToggle');
  const topToggleBtn = $('#toggleSidebarBtn');
  function toggleSidebar(){
    sidebar.classList.toggle('collapsed');
    sidebarToggle.textContent = sidebar.classList.contains('collapsed') ? '▶' : '◀';
  }
  sidebarToggle.addEventListener('pointerdown', e=>{e.preventDefault(); toggleSidebar();});
  topToggleBtn.addEventListener('click', toggleSidebar);

  // Undo/Redo
  const undoBtn = $('#undoBtn'), redoBtn = $('#redoBtn');
  function pushHistory(){
    state.redoStack.length = 0;
    // 軽量にするため shallow copy でOK（ストロークは確定後イミュータブル扱い）
    state._snapshot = state.strokes.slice();
  }
  function commitStroke(){
    if(state.currentStroke){
      state.strokes.push(state.currentStroke);
      state.currentStroke = null;
      pushHistory();
    }
    render();
  }
  undoBtn.addEventListener('click', ()=>{
    if(state.strokes.length){
      const s = state.strokes.pop();
      state.redoStack.push(s);
      render();
    }
  });
  redoBtn.addEventListener('click', ()=>{
    if(state.redoStack.length){
      const s = state.redoStack.pop();
      state.strokes.push(s);
      render();
    }
  });
  window.addEventListener('keydown', (e)=>{
    if(e.ctrlKey && e.key.toLowerCase()==='z'){ e.preventDefault();
      if(e.shiftKey) redoBtn.click(); else undoBtn.click();
    }
  });

  // Text tool (簡易配置)
  const textModal = $('#textModal'), textInput = $('#textInput');
  const textOk = $('#textOk'), textCancel = $('#textCancel');
  const textSize = $('#textSize'), textColor = $('#textColor');
  $('#textBtn').addEventListener('click', ()=>{
    textModal.hidden = false; textInput.focus();
  });
  function closeTextModal(){ textModal.hidden = true; }
  textCancel.addEventListener('click', closeTextModal);
  window.addEventListener('keydown', (e)=>{ if(!textModal.hidden && e.key==='Escape'){ closeTextModal(); }});
  textOk.addEventListener('click', ()=>{
    state.placingText = {
      text: textInput.value||'',
      size: Math.max(8, Math.min(96, parseInt(textSize.value||18,10))),
      color: textColor.value
    };
    closeTextModal();
  });

  // Settings
  const gearModal = $('#gearModal'), gearBtn = $('#gearBtn'), gearClose = $('#gearClose');
  const debugCheck = $('#debugCheck'), debugBox = $('#debug');
  gearBtn.addEventListener('click', ()=>{ gearModal.hidden=false; debugCheck.checked = !debugBox.hidden; });
  gearClose.addEventListener('click', ()=>{ gearModal.hidden=true; });
  debugCheck.addEventListener('change', ()=>{ debugBox.hidden = !debugCheck.checked; });

  if(DEBUG_URL){ debugBox.hidden = false; }

  // --- Input handling ---
  let activePointers = new Map(); // pointerId -> {x,y}
  let pinchRef = null;

  canvas.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);
    activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

    // テキスト配置モードなら文字配置
    if(state.placingText){
      const w = support.worldFromClient(e.clientX, e.clientY);
      const textStroke = { kind:'text', x:w.x, y:w.y, text:state.placingText.text, size:state.placingText.size, color:state.placingText.color, font:'"Noto Sans JP", sans-serif' };
      state.strokes.push(textStroke); state.placingText = null; pushHistory(); render();
      return;
    }

    // 二本指ピンチの初期化（タッチのみ）
    if(e.pointerType==='touch' && activePointers.size===2){
      const pts = Array.from(activePointers.values());
      pinchRef = {
        d: Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y),
        mid:{ x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 },
        scale0: state.scale, tx0: state.tx, ty0: state.ty
      };
      return;
    }

    // Hand（パン）
    if(state.tool==='hand'){
      state.drawing = true; state.pointerId = e.pointerId;
      state._last = {x:e.clientX, y:e.clientY};
      return;
    }

    // Palm rejection: ペン・マーカー時にタッチ無視
    if(palmCheck.checked && (state.tool==='pen' || state.tool==='marker') && e.pointerType==='touch'){
      return; // 無視
    }

    // 描画開始
    if(state.tool==='pen' || state.tool==='marker' || state.tool==='eraser'){
      const w = support.worldFromClient(e.clientX, e.clientY);
      state.currentStroke = {
        kind: state.tool, color: state.color, widthMM: state.widthMM,
        pts: [{x:w.x, y:w.y, p:e.pressure||1, t:performance.now(), tiltX:e.tiltX||0, tiltY:e.tiltY||0}]
      };
      state.drawing = true; state.pointerId = e.pointerId;
      render(); // 開始点反映
    }
  }, {passive:false});

  canvas.addEventListener('pointermove', (e)=>{
    if(!activePointers.has(e.pointerId)) return;
    activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

    // ピンチズーム
    if(pinchRef && activePointers.size===2){
      const pts = Array.from(activePointers.values());
      const d = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      const mid = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };
      const s = Math.max(0.25, Math.min(6, pinchRef.scale0 * (d / (pinchRef.d||1))));
      // 中心を維持するように平行移動を補正
      const before = support.worldFromClient(pinchRef.mid.x, pinchRef.mid.y);
      state.scale = s;
      const after = support.worldFromClient(pinchRef.mid.x, pinchRef.mid.y);
      state.tx += ( (after.x - before.x) * state.scale );
      state.ty += ( (after.y - before.y) * state.scale );
      render(); return;
    }

    if(state.tool==='hand' && state.drawing && state.pointerId===e.pointerId){
      const dx = e.clientX - state._last.x;
      const dy = e.clientY - state._last.y;
      state.tx += dx; state.ty += dy;
      state._last = {x:e.clientX, y:e.clientY};
      render(); return;
    }

    if(state.drawing && state.pointerId===e.pointerId && state.currentStroke){
      // ペン／マーカー／消しゴム
      if(palmCheck.checked && (state.tool==='pen' || state.tool==='marker') && e.pointerType==='touch'){
        return; // 描画中もタッチは無視
      }
      const w = support.worldFromClient(e.clientX, e.clientY);
      const p = e.pressure || 1;
      state.currentStroke.pts.push({x:w.x, y:w.y, p, t:performance.now(), tiltX:e.tiltX||0, tiltY:e.tiltY||0});
      // 軽量な逐次再描画
      render();
    }

    // デバッグ
    debug(`tool:${state.tool} type:${e.pointerType} p:${(e.pressure||1).toFixed(2)} tiltX:${e.tiltX||0} tiltY:${e.tiltY||0} scale:${state.scale.toFixed(2)}`);
  }, {passive:false});

  function endPointer(e){
    activePointers.delete(e.pointerId);
    if(pinchRef && activePointers.size<2){ pinchRef=null; }
    if(state.drawing && state.pointerId===e.pointerId){
      state.drawing=false; state.pointerId=null; commitStroke();
    }
  }
  canvas.addEventListener('pointerup', endPointer, {passive:true});
  canvas.addEventListener('pointercancel', endPointer, {passive:true});
  canvas.addEventListener('pointerout', (e)=>{ if(state.pointerId===e.pointerId && state.drawing){ endPointer(e); } }, {passive:true});

  // ホイール拡大縮小（Ctrl+ホイール）
  canvas.addEventListener('wheel', (e)=>{
    if(!e.ctrlKey) return; e.preventDefault();
    const before = support.worldFromClient(e.clientX, e.clientY);
    const s = Math.max(.25, Math.min(6, state.scale * (e.deltaY<0 ? 1.1 : 0.9)));
    state.scale = s;
    const after = support.worldFromClient(e.clientX, e.clientY);
    state.tx += ( (after.x - before.x) * state.scale );
    state.ty += ( (after.y - before.y) * state.scale );
    render();
  }, {passive:false});

  // --- Rendering ---
  function render(){
    // クリア（キャンバスサイズはCSS px基準で ctx がDPR補正）
    const w = wrap.clientWidth, h = wrap.clientHeight;
    ctx.save();
    ctx.clearRect(0,0,w,h);
    ctx.translate(state.tx, state.ty);
    ctx.scale(state.scale, state.scale);

    for(const s of state.strokes){
      drawStroke(s);
    }
    if(state.currentStroke) drawStroke(state.currentStroke);

    ctx.restore();
  }

  function drawStroke(s){
    if(s.kind==='text'){
      ctx.save();
      ctx.fillStyle = s.color; ctx.font = `${s.size}px ${s.font||'sans-serif'}`;
      ctx.textBaseline='alphabetic';
      ctx.fillText(s.text, s.x, s.y);
      ctx.restore();
      return;
    }
    const basePx = s.widthMM * support.mm2px; // ワールド px（拡大縮小前の幅）
    ctx.lineJoin='round'; ctx.lineCap='round';
    if(s.kind==='eraser'){
      ctx.globalCompositeOperation='destination-out';
      ctx.strokeStyle='rgba(0,0,0,1)';
    }else{
      ctx.globalCompositeOperation='source-over';
      ctx.strokeStyle = s.color;
    }
    ctx.beginPath();
    let last = null;
    for(const p of s.pts){
      const w = basePx * (p.p || 1); // 筆圧で太さ変化
      ctx.lineWidth = Math.max(0.5, w);
      if(!last){ ctx.moveTo(p.x, p.y); last = p; continue; }
      // 簡易スムージング（中点補間）
      const mx = (last.x + p.x) * 0.5;
      const my = (last.y + p.y) * 0.5;
      ctx.quadraticCurveTo(last.x, last.y, mx, my);
      last = p;
    }
    if(last) ctx.lineTo(last.x, last.y);
    // マーカーは半透明
    if(s.kind==='marker'){ ctx.globalAlpha = 0.5; } else { ctx.globalAlpha = 1; }
    ctx.stroke();
    ctx.globalAlpha = 1; ctx.globalCompositeOperation='source-over';
  }

  // --- Debug ---
  function debug(msg){
    if(debugBox.hidden) return;
    debugBox.textContent = [
      msg,
      `scale=${state.scale.toFixed(2)} tx=${state.tx.toFixed(1)} ty=${state.ty.toFixed(1)}`,
      `strokes=${state.strokes.length}${state.currentStroke?' (+drawing)':''}`
    ].join('\n');
  }

  // 初期デバッグ状態
  if(DEBUG_URL){ debug('debug=on'); }

})();
</script>
</body>
</html>
